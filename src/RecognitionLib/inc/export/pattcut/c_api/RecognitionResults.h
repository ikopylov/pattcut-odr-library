#ifndef _PATTCUT_RECOGNITION_RESULTS_C_H_
#define _PATTCUT_RECOGNITION_RESULTS_C_H_

#include "pattcut/export_helper.h"
#include "pattcut/c_api/Common.h"


/** Area of the image, containing detected object
 * @rect_x - X coordinate of the area rectangle
 * @rect_y - Y coordinate of the area rectangle
 * @rect_width - Width of the area rectangle
 * @rect_height - Height of the area rectangle
 * @veracity - Veracity of detection for the current area
 * @is_good - Is this area passed a minimum veracity threshold (usually threshold = 0)
 * @merged_window_count - Window count that formed the current area
 * @combined_strong_cls_output - Accuracy metric calculated from strong classifiers output
 */
PACK(
struct PattCut_CapturedArea
{
	/** X coordinate of the area rectangle */
	int rect_x;
	/** Y coordinate of the area rectangle */
	int rect_y;
	/** Width of the area rectangle */
	int rect_width;
	/** Height of the area rectangle */
	int rect_height;

	/** Veracity of detection for the current area  */
	float veracity;
	/** Is this area passed a minimum veracity threshold (usually threshold = 0) */
	PattCut_BOOL is_good;

	/** Window count that formed the current area */
	int merged_window_count;
	/** Accuracy metric calculated from strong classifiers output */
	float combined_strong_cls_output;
});


/** Recognition result for a separate classifier
 * @classifier_id - Identifier of the classifier that was generated by 'pattcut_load_classifier' function
 * @recognition_time_ms - Recognition time for the current classifier
 * @window_count - Total analized window count
 * @window_count_after_prefilter - Total window count that passed the prefilter classifier
 * @mean_depth - Average number of estimated strong classifiers
 * @mean_weak_cls_count - Average number of estimated weak classifiers
 * @areas_count -  Length of the 'areas' array
 * @areas - Array with all detected areas by this classifier
 */
PACK(
struct PattCut_ResultPerClassifier
{
	/** Identifier of the classifier that was generated by 'pattcut_load_classifier' function */
	int classifier_id;

	/** Recognition time for the current classifier */
	int recognition_time_ms;

	/** Total analized window count */
	int window_count;
	/** Total window count that passed the prefilter classifier */
	int window_count_after_prefilter;

	/** Average number of estimated strong classifiers */
	float mean_depth;
	/** Average number of estimated weak classifiers */
	float mean_weak_cls_count;

	/** Length of the 'areas' array */
	int areas_count;
	/** Array with all detected areas by this classifier */
	PattCut_CapturedArea* areas;
});



/** Recognition results for all used object classifiers
 * @best_classifier_id - Identifier of the best classifier (classifier that detected area with maximal veracity)
 * @total_time_ms - Total recognition time (without image loading time)
 * @result_per_classifier_count - Length of the 'result_per_classifier' array 
 * @result_per_classifier - Array with results from every used object classifier
 */
PACK(
struct PattCut_RecognitionResult
{
	/** Identifier of the best classifier (classifier that detected area with maximal veracity).
	 * Zero or negative value means that there is no areas with 'is_good' flag detected. But the areas still can exist (you should check 'result_per_classifier')
	 */
	int best_classifier_id;

	/** Total recognition time (without image loading time) */
	int total_time_ms;

	/** Length of the 'result_per_classifier' array */
	int result_per_classifier_count;
	/** Array with results from every used object classifier */
	PattCut_ResultPerClassifier* result_per_classifier;
});

#endif